---
phase: 01-shop-module
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shop.v
  - tb_shop.v
autonomous: true

must_haves:
  truths:
    - "buy_valid with action_number 0-4, credit >= discounted price, stock > 0 → credit_out = credit_in - discounted_price, shop_stock[action_number] decremented by 1, grant_onehot[action_number] = 1 for that cycle"
    - "buy_valid with action_number 5-7 → err_invalid_action = 1, credit_out = credit_in, no stock change, grant_onehot = 5'b00000"
    - "buy_valid with action_number 0-4 but credit_in < discounted_price → err_credit = 1, credit_out = credit_in, no stock change, grant_onehot = 5'b00000"
    - "buy_valid with action_number 0-4, sufficient credit, but shop_stock[action_number] = 0 → err_out_of_stock = 1, credit_out = credit_in, no stock change, grant_onehot = 5'b00000"
    - "Error signals are mutually exclusive: invalid_action takes priority over credit, credit takes priority over out_of_stock"
    - "discount_mult = 100 produces no discount; 95 gives 5% off; 90 gives 10% off; 80 gives 20% off — computed as (price_selected * discount_mult) / 100 using integer division"
    - "module shop is standalone with no external dependencies — ready to instantiate twice in game_top.v"
  artifacts:
    - path: "shop.v"
      provides: "Standalone shop module with full purchase/error logic"
      contains: "module shop"
      min_lines: 80
    - path: "tb_shop.v"
      provides: "Standalone testbench exercising all 4 shop error/success paths"
      contains: "module tb_shop"
      min_lines: 60
  key_links:
    - from: "action_number[2:0]"
      to: "shop_stock[action_number]"
      via: "case mux for stock read; guard: only index when action_number <= 4"
      pattern: "shop_stock\\[action_number\\]"
    - from: "price_selected"
      to: "discounted_price"
      via: "(price_selected * discount_mult) / 100 — integer multiply then divide"
      pattern: "price_selected.*discount_mult.*100"
    - from: "purchase_success"
      to: "credit_out, shop_stock update, grant_onehot"
      via: "sequential always @(posedge clk) block; only fires when purchase_success == 1"
      pattern: "purchase_success"
    - from: "grant_onehot[4:0]"
      to: "game_top move inventory counters"
      via: "output port — game_top will increment p_moves[i] when grant_onehot[i] == 1"
      pattern: "grant_onehot"
---

<objective>
Implement shop.v — the standalone per-player shop module — covering all combinational purchase logic, error priority, discount computation, and sequential state updates. Then write tb_shop.v to prove every error path and the success path work correctly before this module is integrated into game_top.v.

Purpose: shop.v will be instantiated twice (one per player) in game_top.v. Getting it provably correct in isolation eliminates the hardest class of bugs before integration.

Output: shop.v (production module), tb_shop.v (standalone verification)
</objective>

<execution_context>
@/Users/alireza/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alireza/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@verilog/verilog_prd_implementation_plan.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement shop.v</name>
  <files>shop.v</files>
  <action>
Create shop.v in the project root with the following exact structure:

**Module signature:**
```verilog
module shop (
    input  wire        clk,
    input  wire        rst,
    input  wire        buy_valid,
    input  wire [2:0]  action_number,
    input  wire [9:0]  credit_in,
    input  wire [6:0]  discount_mult,
    input  wire [9:0]  Price0,
    input  wire [9:0]  Price1,
    input  wire [9:0]  Price2,
    input  wire [9:0]  Price3,
    input  wire [9:0]  Price4,
    output reg         purchase_success,
    output reg         err_invalid_action,
    output reg         err_credit,
    output reg         err_out_of_stock,
    output reg  [9:0]  credit_out,
    output reg  [4:0]  grant_onehot
);
```

**Localparams (inside module, before always blocks):**
```verilog
localparam ACT_KICK  = 3'd0;
localparam ACT_PUNCH = 3'd1;
localparam ACT_LEFT  = 3'd2;
localparam ACT_RIGHT = 3'd3;
localparam ACT_WAIT  = 3'd4;
```

**Internal registers:**
- `reg [3:0] shop_stock [0:4]` — 4-bit stock counter per item (5 entries)
- `reg [9:0] price_selected` — wire holding the muxed price
- `reg [9:0] discounted_price` — holds the final price after discount
- `reg        valid_action` — combinational: action_number <= 4
- `reg        enough_credit` — combinational: credit_in >= discounted_price
- `reg        in_stock` — combinational: shop_stock[action_number] > 0 (only meaningful when valid_action=1)

**Combinational always block (always @(*)):**
1. Price mux:
   ```verilog
   case (action_number)
       3'd0: price_selected = Price0;
       3'd1: price_selected = Price1;
       3'd2: price_selected = Price2;
       3'd3: price_selected = Price3;
       3'd4: price_selected = Price4;
       default: price_selected = 10'd0;
   endcase
   ```
2. Discount: `discounted_price = (price_selected * discount_mult) / 100;`
   Note: price_selected is 10-bit, discount_mult is 7-bit. For the multiplication, use a 17-bit intermediate: `wire [16:0] price_tmp = price_selected * discount_mult; discounted_price = price_tmp / 100;` — or compute it directly as a local reg in the always block. The division by 100 is integer (truncating), which is correct.
3. `valid_action = (action_number <= 3'd4);`
4. Stock guard: `in_stock = (valid_action) ? (shop_stock[action_number] > 0) : 1'b0;`
   IMPORTANT: Do NOT index shop_stock with action_number when action_number is 5-7; the guard above handles this safely.
5. `enough_credit = (credit_in >= discounted_price);`
6. `purchase_success = buy_valid & valid_action & enough_credit & in_stock;`
7. Error signals (mutually exclusive, error only fires when buy_valid=1 and success=0):
   ```verilog
   err_invalid_action = buy_valid & ~valid_action;
   err_credit         = buy_valid &  valid_action & ~enough_credit;
   err_out_of_stock   = buy_valid &  valid_action &  enough_credit & ~in_stock;
   ```
   Priority is naturally encoded: invalid_action fires first (no valid_action check on credit/stock), credit fires only if action is valid, out_of_stock fires only if action valid and credit sufficient.
8. Default: if no error and no success (buy_valid=0), all error outputs = 0, purchase_success = 0.

**Sequential always block (always @(posedge clk or posedge rst)):**
```
if (rst):
  - Initialize all shop_stock[0..4] to a reasonable default (use 4'd5 — 5 units each)
  - grant_onehot <= 5'b00000
  - credit_out <= credit_in  (pass-through on reset; game_top owns actual credit register)
else:
  grant_onehot <= 5'b00000;   // default: no grant this cycle
  if (purchase_success):
    credit_out          <= credit_in - discounted_price;
    shop_stock[action_number] <= shop_stock[action_number] - 4'd1;
    grant_onehot[action_number] <= 1'b1;   // one-hot pulse for this cycle only
  else:
    credit_out <= credit_in;  // pass credit through unchanged
```

Note on grant_onehot: it is registered output, asserted for exactly one clock cycle when a purchase succeeds. Game_top will sample it on the NEXT posedge and increment the player's move counter for that move. This is the clean interface described in the PRD.

Note on credit_out: shop.v does NOT own the credit register — game_top.v will hold p1_credit and p2_credit. shop.v computes and outputs the updated value; game_top.v stores it. On failed purchases, credit_out = credit_in (no change). On reset, credit_out reflects credit_in (game_top will reset credit_in to 500 via its own reset).

**Do NOT:**
- Use SystemVerilog syntax (no logic, no always_comb, no always_ff, no packed arrays, no unique case)
- Use 2D packed arrays — `reg [3:0] shop_stock [0:4]` is the correct plain-Verilog unpacked array syntax
- Add `$display` statements — those come in Phase 4

**Verify compilation:**
Run `iverilog -o /dev/null shop.v` (syntax check only, no testbench needed yet). Must produce zero errors and zero warnings (except possible "timescale" warning which is acceptable).
  </action>
  <verify>
Run: `iverilog -o /dev/null /Users/alireza/Documents/Claude/Yahya/shop.v`

Expected: exits with code 0, no errors. Any warning about "timescale" is acceptable. Any error about undeclared signals, syntax, or type mismatch must be fixed before proceeding to Task 2.
  </verify>
  <done>
shop.v exists at project root, compiles cleanly with iverilog, and contains: module shop with all 11 inputs and 6 outputs as specified, localparams for 5 action codes, shop_stock[0:4] 4-bit unpacked array initialized to 5 on reset, combinational price mux, integer discount multiply-divide, mutually exclusive error signals with correct priority, and sequential credit_out/grant_onehot update on posedge clk.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write and run tb_shop.v standalone testbench</name>
  <files>tb_shop.v</files>
  <action>
Create tb_shop.v in the project root. This is a disposable standalone testbench (NOT the final tb_game.v which comes in Phase 4 — do not conflate them). Its only job is to prove shop.v's 4 error paths and success path work before integration.

**Module structure:**
```verilog
`timescale 1ns/1ps
module tb_shop;
    // DUT connections
    reg        clk, rst, buy_valid;
    reg  [2:0] action_number;
    reg  [9:0] credit_in;
    reg  [6:0] discount_mult;
    reg  [9:0] Price0, Price1, Price2, Price3, Price4;
    wire       purchase_success, err_invalid_action, err_credit, err_out_of_stock;
    wire [9:0] credit_out;
    wire [4:0] grant_onehot;

    // Instantiate DUT
    shop dut (
        .clk(clk), .rst(rst), .buy_valid(buy_valid),
        .action_number(action_number), .credit_in(credit_in),
        .discount_mult(discount_mult),
        .Price0(Price0), .Price1(Price1), .Price2(Price2),
        .Price3(Price3), .Price4(Price4),
        .purchase_success(purchase_success),
        .err_invalid_action(err_invalid_action),
        .err_credit(err_credit),
        .err_out_of_stock(err_out_of_stock),
        .credit_out(credit_out),
        .grant_onehot(grant_onehot)
    );

    // Clock: 10ns period
    initial clk = 0;
    always #5 clk = ~clk;
```

**Test sequence (in an `initial` block):**

Setup:
- rst=1, buy_valid=0, discount_mult=7'd100 (no discount)
- Prices: Price0=120, Price1=200, Price2=50, Price3=50, Price4=10
- credit_in=10'd500, action_number=3'd0
- Wait 2 clock cycles, then rst=0.
- Wait 1 more clock cycle (stock is now 5 for each item from reset).

Test A — Invalid action (SHOP-02):
- Set action_number=3'd6, buy_valid=1
- Wait 1 clock cycle (@negedge clk to sample outputs after posedge)
- `$display("TEST A: err_invalid_action=%b (expect 1), purchase_success=%b (expect 0), credit_out=%0d (expect 500)", err_invalid_action, purchase_success, credit_out);`
- Set buy_valid=0, wait 1 cycle.

Test B — Insufficient credit (SHOP-03):
- Set action_number=3'd1, credit_in=10'd50, buy_valid=1  (Punch costs 200, credit only 50)
- Wait 1 clock cycle
- `$display("TEST B: err_credit=%b (expect 1), err_invalid_action=%b (expect 0), purchase_success=%b (expect 0), credit_out=%0d (expect 50)", err_credit, err_invalid_action, purchase_success, credit_out);`
- Set buy_valid=0, wait 1 cycle.

Test C — Successful purchase (SHOP-05):
- Set action_number=3'd0, credit_in=10'd500, buy_valid=1  (Kick costs 120, credit=500)
- Wait 1 clock cycle (posedge: shop_stock[0] decrements, credit_out updated, grant_onehot[0] pulses)
- `$display("TEST C: purchase_success=%b (expect 1), credit_out=%0d (expect 380), grant_onehot=%b (expect 00001)", purchase_success, credit_out, grant_onehot);`
- Set buy_valid=0; credit_in=credit_out (simulate game_top storing updated credit); wait 1 cycle.

Test D — Out of stock (SHOP-04):
- Buy item 0 (Kick, cost 120) four more times to drain remaining 4 stock, updating credit_in each time.
  (After Test C: stock[0]=4, credit=380. After 4 more purchases: stock[0]=0, credit=380-4*120=380-480 → credit will go negative risk if starting from 500 and buying 5 total. Use credit_in=10'd1000 for tests C and D to avoid running out of credit.)

  Actually: reset credit_in=10'd1000 before Test C. Then buy Kick (cost 120) 5 times total to drain stock. After 5 purchases: stock[0]=0.

- On the 6th attempt: set buy_valid=1, action_number=3'd0
- Wait 1 clock cycle
- `$display("TEST D: err_out_of_stock=%b (expect 1), purchase_success=%b (expect 0), credit_out=%0d (expect unchanged)", err_out_of_stock, purchase_success, credit_out);`
- Set buy_valid=0.

Test E — Discount verification (discount_mult=80 = 20% off):
- Reset DUT: rst=1 for 2 cycles, rst=0
- Set credit_in=10'd1000, discount_mult=7'd80, action_number=3'd0 (Kick, Price0=120)
- Expected discounted_price = (120 * 80) / 100 = 96
- Set buy_valid=1, wait 1 cycle
- `$display("TEST E: purchase_success=%b (expect 1), credit_out=%0d (expect 904), grant_onehot=%b (expect 00001)", purchase_success, credit_out, grant_onehot);`

End:
```verilog
    $display("--- tb_shop complete ---");
    $finish;
```

**Compile and run command:**
```
iverilog -o /tmp/tb_shop_sim /Users/alireza/Documents/Claude/Yahya/tb_shop.v /Users/alireza/Documents/Claude/Yahya/shop.v && vvp /tmp/tb_shop_sim
```

If iverilog is not installed, try: `which iverilog || brew install icarus-verilog`

Examine the output. All EXPECT values must match. If any mismatch, fix shop.v (not tb_shop.v) and re-run.
  </action>
  <verify>
Run: `iverilog -o /tmp/tb_shop_sim /Users/alireza/Documents/Claude/Yahya/tb_shop.v /Users/alireza/Documents/Claude/Yahya/shop.v && vvp /tmp/tb_shop_sim`

Expected output contains all of:
- TEST A: err_invalid_action=1 ... purchase_success=0
- TEST B: err_credit=1 ... purchase_success=0
- TEST C: purchase_success=1, credit_out=380 (or 904 if credit adjusted), grant_onehot=00001
- TEST D: err_out_of_stock=1, purchase_success=0
- TEST E: purchase_success=1, credit_out=904 (1000 - 96), grant_onehot=00001
- "--- tb_shop complete ---"

Zero compilation errors required. Zero simulation mismatches required.
  </verify>
  <done>
tb_shop.v compiles with shop.v and produces passing output for all 5 tests: invalid action caught, credit error caught, successful purchase with correct credit deduction and grant_onehot pulse, out-of-stock caught after draining stock, and discount computation verified at 80x/100. shop.v is ready for integration into game_top.v in Phase 2.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `iverilog -o /dev/null /Users/alireza/Documents/Claude/Yahya/shop.v` — exits 0, no errors
2. `iverilog -o /tmp/tb_shop_sim /Users/alireza/Documents/Claude/Yahya/tb_shop.v /Users/alireza/Documents/Claude/Yahya/shop.v && vvp /tmp/tb_shop_sim` — all 5 test lines show expected values
3. shop.v uses only plain Verilog constructs — grep confirms: no `logic`, no `always_comb`, no `always_ff`, no SystemVerilog keywords
4. Module port list matches exactly: 11 inputs (clk, rst, buy_valid, action_number[2:0], credit_in[9:0], discount_mult[6:0], Price0-4[9:0]), 6 outputs (purchase_success, err_invalid_action, err_credit, err_out_of_stock, credit_out[9:0], grant_onehot[4:0])
5. No `$display` in shop.v (those come in Phase 4)

SHOP-01 through SHOP-05 all verified by testbench output.
</verification>

<success_criteria>
- shop.v exists at /Users/alireza/Documents/Claude/Yahya/shop.v
- tb_shop.v exists at /Users/alireza/Documents/Claude/Yahya/tb_shop.v
- Both files compile together with iverilog without errors
- Simulation output shows all 5 tests passing with correct values
- shop.v is standalone (no `include` dependencies, no hardcoded prices — all come in via port)
- shop.v is ready to instantiate twice in game_top.v in Phase 2
</success_criteria>

<output>
After completion, create `/Users/alireza/Documents/Claude/Yahya/.planning/phases/01-shop-module/01-01-SUMMARY.md` with:
- What was built (shop.v interface, internal structure, key design decisions)
- Simulation results (paste actual test output)
- Any deviations from this plan and why
- Port list reference for Phase 2 (game_top.v instantiation)
</output>
