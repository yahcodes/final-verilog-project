---
phase: 03-win-restart-and-extra-credit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - game_top.v
autonomous: true

must_haves:
  truths:
    - "When a player's health reaches 0 from an attack, phase transitions to SHOP and winner is latched in the same cycle"
    - "moves_to_win increments by 1 for every move where inventory was consumed (no err_no_inventory)"
    - "On start_round pulse, phase goes to PLAY, winner resets to 2'b00, moves_to_win resets to 0"
    - "Health underflow is guarded — health never wraps below 0"
  artifacts:
    - path: "game_top.v"
      provides: "Win detection, moves_to_win counter, start_round restart"
      contains: "moves_to_win"
  key_links:
    - from: "game_top.v PLAY attack branches"
      to: "win detection logic"
      via: "health <= damage comparison before subtraction"
      pattern: "p[12]_health\\s*<="
---

<objective>
Add win detection with health underflow guards, moves_to_win counter, and start_round restart logic to game_top.v.

Purpose: Enable the game to detect round endings, count move efficiency, and restart rounds from SHOP.
Output: Modified game_top.v with all Phase 3 sequential logic (discount mux wiring deferred to plan 02).
</objective>

<execution_context>
@/Users/alireza/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alireza/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@game_top.v
@.planning/phases/03-win-restart-and-extra-credit/03-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add moves_to_win register and win-guarded attack logic</name>
  <files>game_top.v</files>
  <action>
Modify game_top.v with these changes:

1. Add a new register declaration after the existing registers:
   ```
   reg [3:0] moves_to_win;
   ```

2. In the rst block, add:
   ```
   moves_to_win <= 4'd0;
   ```

3. Replace the ENTIRE PLAY phase block (the `end else begin // PHASE_PLAY` section) with win-guarded logic. The structure for EACH attack/move branch that has inventory (the `else` after `err_no_inventory`) must:
   - First: increment moves_to_win (`moves_to_win <= moves_to_win + 4'd1;`)
   - Then: decrement inventory
   - Then: for attacks, check if the hit would kill BEFORE applying damage

   Specifically, replace the P1 active attack branches:

   **P1 Kick (ACT_KICK, turn==0):**
   ```
   ACT_KICK: begin
       if (p1_moves[0] == 4'd0) begin
           err_no_inventory <= 1'b1;
       end else begin
           moves_to_win <= moves_to_win + 4'd1;
           p1_moves[0] <= p1_moves[0] - 4'd1;
           if (distance == 3'd1) begin
               if (p2_health <= 2'd1) begin
                   // WIN: P1 wins
                   phase <= PHASE_SHOP;
                   winner <= 2'b01;
                   p1_health <= 2'd3;
                   p2_health <= 2'd3;
                   p1_credit <= 10'd500;
                   p2_credit <= 10'd500;
                   p1_pos <= 2'd2;
                   p2_pos <= 2'd2;
                   p1_moves[0] <= 4'd0; p1_moves[1] <= 4'd0; p1_moves[2] <= 4'd0; p1_moves[3] <= 4'd0; p1_moves[4] <= 4'd0;
                   p2_moves[0] <= 4'd0; p2_moves[1] <= 4'd0; p2_moves[2] <= 4'd0; p2_moves[3] <= 4'd0; p2_moves[4] <= 4'd0;
               end else begin
                   p2_health <= p2_health - 2'd1;
               end
           end else begin
               err_wrong_distance <= 1'b1;
           end
       end
   end
   ```

   **P1 Punch (ACT_PUNCH, turn==0):**
   Same pattern but: `p1_moves[1]`, distance check is `== 3'd0`, health check is `p2_health <= 2'd2`, damage is `- 2'd2`, winner is `2'b01`.

   **P1 MoveLeft, MoveRight, Wait:** Keep existing logic but add `moves_to_win <= moves_to_win + 4'd1;` as first line in the `else` (inventory available) branch. No win detection needed for these.

   **P2 active (turn==1):** Mirror of P1 but:
   - P2 Kick: `p2_moves[0]`, attacks p1_health, `p1_health <= 2'd1`, winner is `2'b10`
   - P2 Punch: `p2_moves[1]`, attacks p1_health, `p1_health <= 2'd2`, damage `- 2'd2`, winner is `2'b10`
   - P2 moves/wait: same pattern with moves_to_win increment

   IMPORTANT: The win block resets health/credit/pos/moves for BOTH players (entering SHOP fresh). It does NOT reset moves_to_win (preserved for discount calculation).

4. In the SHOP phase block, add start_round handling. Replace the existing single line:
   ```
   if (start_round) phase <= PHASE_PLAY;
   ```
   with:
   ```
   if (start_round) begin
       phase <= PHASE_PLAY;
       winner <= 2'b00;
       moves_to_win <= 4'd0;
   end
   ```
   Note: health/credit/pos/moves are NOT reset by start_round (already reset at win detection; moves bought in SHOP must carry into PLAY).
  </action>
  <verify>Run `iverilog -o /dev/null shop.v game_top.v` — must compile with zero errors and zero warnings.</verify>
  <done>game_top.v compiles cleanly with: moves_to_win register, win-guarded attack branches for all 4 attack cases (P1 kick/punch, P2 kick/punch), moves_to_win increment on all non-err_no_inventory moves, start_round resetting phase/winner/moves_to_win.</done>
</task>

</tasks>

<verification>
- `iverilog -o /dev/null shop.v game_top.v` compiles cleanly
- game_top.v contains `moves_to_win` register
- All 4 attack branches (P1 kick, P1 punch, P2 kick, P2 punch) have health underflow guards
- start_round resets winner and moves_to_win but NOT health/credit/pos/moves
</verification>

<success_criteria>
game_top.v has win detection, moves_to_win counter, and start_round logic. Compiles cleanly with iverilog.
</success_criteria>

<output>
After completion, create `.planning/phases/03-win-restart-and-extra-credit/03-01-SUMMARY.md`
</output>
