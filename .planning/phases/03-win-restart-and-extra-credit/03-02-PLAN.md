---
phase: 03-win-restart-and-extra-credit
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - game_top.v
  - tb_phase3.v
autonomous: true

must_haves:
  truths:
    - "Winner's shop prices reflect correct discount band based on moves_to_win"
    - "Loser always pays full price (mult=100)"
    - "When winner=2'b00 (no winner), both players get mult=100"
    - "Testbench verifies win detection, moves_to_win counting, restart, and all 3 discount bands"
  artifacts:
    - path: "game_top.v"
      provides: "Discount mux wired to shop instances"
      contains: "p1_discount_mult"
    - path: "tb_phase3.v"
      provides: "Phase 3 verification testbench"
      contains: "initial begin"
  key_links:
    - from: "game_top.v discount mux"
      to: "shop_p1/shop_p2 .discount_mult port"
      via: "wire replacement from 7'd100 to p1_discount_mult/p2_discount_mult"
      pattern: "discount_mult\\s*\\(p[12]_discount_mult\\)"
---

<objective>
Add combinational discount multiplier mux to game_top.v, wire it to both shop instances, and create tb_phase3.v to verify all Phase 3 functionality.

Purpose: Complete the discount extra credit feature and verify all Phase 3 behaviors end-to-end.
Output: Modified game_top.v with discount wiring, new tb_phase3.v testbench.
</objective>

<execution_context>
@/Users/alireza/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alireza/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@game_top.v
@shop.v
@.planning/phases/03-win-restart-and-extra-credit/03-CONTEXT.md
@.planning/phases/03-win-restart-and-extra-credit/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add discount mux and wire to shop instances</name>
  <files>game_top.v</files>
  <action>
Add the combinational discount multiplier mux to game_top.v and wire it to shop instances.

1. Add two reg declarations near the top (after the distance wire, before shop instances):
   ```
   reg [6:0] p1_discount_mult;
   reg [6:0] p2_discount_mult;
   ```

2. Add a combinational always block BEFORE the shop instantiations:
   ```
   always @(*) begin
       if (winner == 2'b01) begin
           if      (moves_to_win <= 4'd6)  p1_discount_mult = 7'd80;
           else if (moves_to_win <= 4'd9)  p1_discount_mult = 7'd90;
           else                            p1_discount_mult = 7'd95;
           p2_discount_mult = 7'd100;
       end else if (winner == 2'b10) begin
           p1_discount_mult = 7'd100;
           if      (moves_to_win <= 4'd6)  p2_discount_mult = 7'd80;
           else if (moves_to_win <= 4'd9)  p2_discount_mult = 7'd90;
           else                            p2_discount_mult = 7'd95;
       end else begin
           p1_discount_mult = 7'd100;
           p2_discount_mult = 7'd100;
       end
   end
   ```

3. In shop_p1 instantiation, change `.discount_mult(7'd100)` to `.discount_mult(p1_discount_mult)`.
   In shop_p2 instantiation, change `.discount_mult(7'd100)` to `.discount_mult(p2_discount_mult)`.

Verify: `iverilog -o /dev/null shop.v game_top.v` compiles cleanly.
  </action>
  <verify>Run `iverilog -o /dev/null shop.v game_top.v` — zero errors.</verify>
  <done>Discount mux produces correct mult values based on winner and moves_to_win; shop instances receive dynamic discount_mult.</done>
</task>

<task type="auto">
  <name>Task 2: Create tb_phase3.v verification testbench</name>
  <files>tb_phase3.v</files>
  <action>
Create tb_phase3.v that verifies all Phase 3 success criteria. Use plain Verilog (no SystemVerilog). Use $display for output.

Structure:
- Instantiate game_top with all ports
- Clock generation: `always #5 clk = ~clk;`
- Set prices: Price0=100, Price1=150, Price2=50, Price3=50, Price4=30
- Helper tasks: `task do_buy_p1(input [2:0] action);` and similar for p2, `task do_play(input turn_val, input [2:0] action);`

All discount verification is behavioral: after a winner buys an item, check the p1_credit / p2_credit output port value. Do NOT reference internal signals like p1_discount_mult or p2_discount_mult — these are internal regs with no output port. The observable effect is: credit_after = credit_before - (price * mult / 100).

Test scenarios (sequential in a single initial block):

**Test 1: Win detection — P1 wins in 6 moves (band: <=6, mult=80)**
- rst.
- SHOP phase buys: P1 buys 3 Kick (buy_code=0) + 2 MoveRight (buy_code=4). P2 buys 1 MoveLeft (buy_code=3).
- Fire start_round (one clock pulse).
- PLAY sequence (alternating turns, P1=turn 0, P2=turn 1):
  1. P1 MoveRight (action=4): p1_pos 2->1.
  2. P1 MoveRight (action=4): p1_pos 1->0.
  3. P2 MoveLeft (action=3): p2_pos 2->1. Distance = 0+1 = 1.
  4. P1 Kick (action=0): P2 health 3->2.
  5. P1 Kick (action=0): P2 health 2->1.
  6. P1 Kick (action=0): P2 health 1->0. Win triggered.
- Total valid moves = 6. moves_to_win = 6. Band: <=6, mult=80.
- Verify via output ports: phase==PHASE_SHOP (2'b00), winner==2'b01.
- Now P1 buys item 0 (Price0=100). Expected discounted cost = 100*80/100 = 80. Record p1_credit before buy, then after buy check: credit_before - p1_credit == 80. If P1 started with 500 and spent 5 buys in first shop (5*cost), calculate expected credit accordingly. Alternatively, just read p1_credit before and after the post-win buy and verify the delta equals 80.
- $display PASS/FAIL for winner, phase, and discount cost.

**Test 2: start_round resets correctly**
- After Test 1's win state, fire start_round.
- Verify: phase==PHASE_PLAY (2'b01), winner==2'b00.
- P1 buys item 0 after another rst+start cycle with no winner: verify credit delta == 100 (full price, since winner==0).
- $display PASS/FAIL.

**Test 3: P1 wins in 8 moves (band: 7-9, mult=90)**
- rst.
- SHOP buys: P1 buys 3 Kick + 2 MoveRight + 1 Wait (buy_code=5). P2 buys 1 MoveLeft + 1 Wait.
- Fire start_round.
- PLAY sequence:
  1. P1 MoveRight: p1_pos 2->1.
  2. P1 MoveRight: p1_pos 1->0.
  3. P2 MoveLeft: p2_pos 2->1. Distance=1.
  4. P1 Wait.
  5. P2 Wait.
  6. P1 Kick: P2 health 3->2.
  7. P1 Kick: P2 health 2->1.
  8. P1 Kick: P2 health 1->0. Win triggered.
- Total valid moves = 8. Band: 7-9, mult=90.
- Verify winner==2'b01 via output port.
- P1 buys item 0 (Price0=100). Verify credit delta == 90 (100*90/100).
- $display PASS/FAIL.

**Test 4: P1 wins in 12 moves (band: >=10, mult=95)**
- rst.
- SHOP buys: P1 buys 3 Kick + 2 MoveRight + 4 Wait. P2 buys 1 MoveLeft + 2 Wait.
- Fire start_round.
- PLAY sequence:
  1. P1 MoveRight: p1_pos 2->1.
  2. P1 MoveRight: p1_pos 1->0.
  3. P2 MoveLeft: p2_pos 2->1. Distance=1.
  4-9. P1 Wait x3, P2 Wait x2, P1 Wait x1 (6 more moves, running total=9).
  10. P1 Kick: P2 health 3->2.
  11. P1 Kick: P2 health 2->1.
  12. P1 Kick: P2 health 1->0. Win triggered.
- Total valid moves = 12. Band: >=10, mult=95.
- Verify winner==2'b01 via output port.
- P1 buys item 0 (Price0=100). Verify credit delta == 95.
- $display PASS/FAIL.

**Test 5: P2 wins (winner==2'b10)**
- Similar setup but P2 attacks P1 to death with kicks. Verify winner==2'b10, P2 gets discount, P1 pays full price (credit delta == 100 for P1 buy).
- $display PASS/FAIL.

Use `$display` for all checks. End with `$finish`.

Keep it focused — verify the 5 success criteria scenarios, don't over-engineer.
  </action>
  <verify>Run `iverilog -o tb_phase3 shop.v game_top.v tb_phase3.v && vvp tb_phase3` — all tests print PASS, no FAIL.</verify>
  <done>tb_phase3.v exercises: win detection (health=0 triggers SHOP+winner latch), moves_to_win counting, start_round restart, and all 3 discount bands (<=6 at 80, 7-9 at 90, >=10 at 95). All checks PASS.</done>
</task>

</tasks>

<verification>
- `iverilog -o /dev/null shop.v game_top.v` compiles cleanly
- `iverilog -o tb_phase3 shop.v game_top.v tb_phase3.v && vvp tb_phase3` runs with all PASS
- Discount mux produces 80/90/95/100 based on winner and moves_to_win
- shop instances wired to dynamic discount_mult (not hardcoded 7'd100)
</verification>

<success_criteria>
Discount mux wired, tb_phase3.v passes all tests covering win detection, moves_to_win, start_round, and all 3 discount bands.
</success_criteria>

<output>
After completion, create `.planning/phases/03-win-restart-and-extra-credit/03-02-SUMMARY.md`
</output>
