---
phase: 03-win-restart-and-extra-credit
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - game_top.v
  - tb_phase3.v
autonomous: true

must_haves:
  truths:
    - "Winner's shop prices reflect correct discount band based on moves_to_win"
    - "Loser always pays full price (mult=100)"
    - "When winner=2'b00 (no winner), both players get mult=100"
    - "Testbench verifies win detection, moves_to_win counting, restart, and all 3 discount bands"
  artifacts:
    - path: "game_top.v"
      provides: "Discount mux wired to shop instances"
      contains: "p1_discount_mult"
    - path: "tb_phase3.v"
      provides: "Phase 3 verification testbench"
      contains: "initial begin"
  key_links:
    - from: "game_top.v discount mux"
      to: "shop_p1/shop_p2 .discount_mult port"
      via: "wire replacement from 7'd100 to p1_discount_mult/p2_discount_mult"
      pattern: "discount_mult\\s*\\(p[12]_discount_mult\\)"
---

<objective>
Add combinational discount multiplier mux to game_top.v, wire it to both shop instances, and create tb_phase3.v to verify all Phase 3 functionality.

Purpose: Complete the discount extra credit feature and verify all Phase 3 behaviors end-to-end.
Output: Modified game_top.v with discount wiring, new tb_phase3.v testbench.
</objective>

<execution_context>
@/Users/alireza/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alireza/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@game_top.v
@shop.v
@.planning/phases/03-win-restart-and-extra-credit/03-CONTEXT.md
@.planning/phases/03-win-restart-and-extra-credit/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add discount mux and wire to shop instances</name>
  <files>game_top.v</files>
  <action>
Add the combinational discount multiplier mux to game_top.v and wire it to shop instances.

1. Add two reg declarations near the top (after the distance wire, before shop instances):
   ```
   reg [6:0] p1_discount_mult;
   reg [6:0] p2_discount_mult;
   ```

2. Add a combinational always block BEFORE the shop instantiations:
   ```
   always @(*) begin
       if (winner == 2'b01) begin
           if      (moves_to_win <= 4'd6)  p1_discount_mult = 7'd80;
           else if (moves_to_win <= 4'd9)  p1_discount_mult = 7'd90;
           else                            p1_discount_mult = 7'd95;
           p2_discount_mult = 7'd100;
       end else if (winner == 2'b10) begin
           p1_discount_mult = 7'd100;
           if      (moves_to_win <= 4'd6)  p2_discount_mult = 7'd80;
           else if (moves_to_win <= 4'd9)  p2_discount_mult = 7'd90;
           else                            p2_discount_mult = 7'd95;
       end else begin
           p1_discount_mult = 7'd100;
           p2_discount_mult = 7'd100;
       end
   end
   ```

3. In shop_p1 instantiation, change `.discount_mult(7'd100)` to `.discount_mult(p1_discount_mult)`.
   In shop_p2 instantiation, change `.discount_mult(7'd100)` to `.discount_mult(p2_discount_mult)`.

Verify: `iverilog -o /dev/null shop.v game_top.v` compiles cleanly.
  </action>
  <verify>Run `iverilog -o /dev/null shop.v game_top.v` — zero errors.</verify>
  <done>Discount mux produces correct mult values based on winner and moves_to_win; shop instances receive dynamic discount_mult.</done>
</task>

<task type="auto">
  <name>Task 2: Create tb_phase3.v verification testbench</name>
  <files>tb_phase3.v</files>
  <action>
Create tb_phase3.v that verifies all Phase 3 success criteria. Use plain Verilog (no SystemVerilog). Use $display for output.

Structure:
- Instantiate game_top with all ports
- Clock generation: `always #5 clk = ~clk;`
- Set prices: Price0=100, Price1=150, Price2=50, Price3=50, Price4=30
- Helper tasks: `task do_buy_p1(input [2:0] action);` and similar for p2, `task do_play(input turn_val, input [2:0] action);`

Test scenarios (sequential in a single initial block):

**Test 1: Win detection — P1 wins by kick**
- rst, then buy 3 kicks for P1 (3 cycles buy_valid_p1 with buy_code_p1=0)
- start_round to enter PLAY
- Move P1 left (action 2) to get distance=3 (no, P1 starts at pos 2, P2 at pos 2, distance=4)
- Actually: buy MoveRight for P1 to get closer. Buy kicks. Plan a sequence where P1 can kick P2 to death.
- Simpler: buy 3 kicks for P1. start_round. P1 MoveRight (pos 2->1, distance=1+2=3, too far). Need to think about distance = p1_pos + p2_pos. Both start at 2, distance=4. P1 MoveRight: p1_pos=1, distance=3. P1 MoveRight again: p1_pos=0, distance=2. Still not 1. P2 MoveLeft: p2_pos=1, distance=1. Now kick works.
- So buy: P1 gets 3 kicks + 0 MoveRight. P2 gets 1 MoveLeft. Then start_round.
- Play sequence: P2 MoveLeft (p2_pos 2->1, distance=0+1... wait, P2 MoveLeft decreases p2_pos. p2_pos=2, MoveLeft: p2_pos > 0, so p2_pos=1. distance = p1_pos + p2_pos = 2+1=3. Still not 1.
- Hmm. distance = p1_pos + p2_pos. For kick (distance==1): need p1_pos + p2_pos == 1. So one at 0, one at 1. P1 MoveRight twice: p1_pos=0. P2 MoveLeft twice: p2_pos=0. distance=0 (punch range). Need p1=0, p2=1 for distance=1.
- Plan: P1 buys 3 kicks + 2 MoveRight. P2 buys 1 MoveLeft. start_round.
  - P1 MoveRight (p1_pos 2->1), P1 MoveRight (p1_pos 1->0), P2 MoveLeft (p2_pos 2->1). distance = 0+1 = 1.
  - P1 Kick x3 (each does 1 damage to P2, health 3->2->1->0, third kick triggers win).
  - Total valid moves = 2 MoveRight + 1 MoveLeft + 3 Kick = 6. moves_to_win = 6. Discount band: <= 6 → mult=80.
- After win: check phase==PHASE_SHOP, winner==2'b01, moves_to_win==6.
- Check discount: p1_discount_mult should be 80, p2_discount_mult should be 100.
- Buy something for P1 and verify discounted price: Price0=100, mult=80 → discounted=80. P1 credit starts at 500, after buy: 500-80=420.
- $display results and check with if statements, $display "PASS" or "FAIL".

**Test 2: start_round resets correctly**
- After Test 1's win, fire start_round.
- Check: phase==PHASE_PLAY, winner==2'b00, moves_to_win==0.
- Check: discount mults both 100 now.

**Test 3: moves_to_win = 10 → mult=95 band**
- rst. Buy P1: 3 kicks + 2 MoveRight + 5 Wait. Buy P2: 1 MoveLeft + 5 Wait (need 5 wait + 1 moveleft = 6 buys, credit allows).
- start_round. Execute: P1 MoveRight, P1 MoveRight, P2 MoveLeft (distance=1). Then P1 Wait x4, P2 Wait x4 (8 more moves, total 11). Then P1 Kick x3 (3 more, but 3rd triggers win, total valid = 2+1+4+4+3 = 14, but wait — P2 only has 5 waits and 1 moveleft = 6 moves total. P1 has 3 kicks + 2 moveright + 5 wait = 10 moves. Let me just do 10+ moves).
- Actually simpler: just make moves_to_win >= 10. Any sequence with 10+ valid moves.
- After win check p1_discount_mult == 95.

**Test 4: P2 wins (winner==2'b10)**
- Similar setup but P2 attacks P1 to death. Verify winner==2'b10, P2 gets discount, P1 gets 100.

Use `$display` for all checks. End with `$finish`.

Keep it focused — verify the 4 success criteria, don't over-engineer.
  </action>
  <verify>Run `iverilog -o tb_phase3 shop.v game_top.v tb_phase3.v && vvp tb_phase3` — all tests print PASS, no FAIL.</verify>
  <done>tb_phase3.v exercises: win detection (health=0 triggers SHOP+winner latch), moves_to_win counting, start_round restart, and at least 2 discount bands. All checks PASS.</done>
</task>

</tasks>

<verification>
- `iverilog -o /dev/null shop.v game_top.v` compiles cleanly
- `iverilog -o tb_phase3 shop.v game_top.v tb_phase3.v && vvp tb_phase3` runs with all PASS
- Discount mux produces 80/90/95/100 based on winner and moves_to_win
- shop instances wired to dynamic discount_mult (not hardcoded 7'd100)
</verification>

<success_criteria>
Discount mux wired, tb_phase3.v passes all tests covering win detection, moves_to_win, start_round, and discount bands.
</success_criteria>

<output>
After completion, create `.planning/phases/03-win-restart-and-extra-credit/03-02-SUMMARY.md`
</output>
