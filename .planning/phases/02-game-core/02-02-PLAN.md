---
phase: 02-game-core
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified: [game_top.v, tb_game_core.v]
autonomous: true

must_haves:
  truths:
    - "Kick at distance=1 reduces opponent health by 1"
    - "Punch at distance=0 reduces opponent health by 2"
    - "Kick/Punch at wrong distance deals no damage but consumes inventory"
    - "MoveLeft/MoveRight adjust position with saturation at 0 and 2"
    - "Saturated moves still consume inventory"
    - "Wait consumes Wait counter, changes no other state"
    - "Action with move counter=0 triggers err_no_inventory, no state change"
    - "Only active player's state changes; inactive player unaffected"
  artifacts:
    - path: "game_top.v"
      provides: "Complete PLAY phase action logic"
      contains: "ACT_KICK"
    - path: "tb_game_core.v"
      provides: "Phase 2 verification testbench"
      contains: "tb_game_core"
  key_links:
    - from: "game_top.v PLAY block"
      to: "p1_moves/p2_moves counters"
      via: "inventory check before action execution"
      pattern: "err_no_inventory"
    - from: "game_top.v PLAY block"
      to: "distance wire"
      via: "distance check for Kick/Punch"
      pattern: "err_wrong_distance"
---

<objective>
Fill in the PLAY phase stub in game_top.v with complete action execution logic (Kick, Punch, MoveLeft, MoveRight, Wait) including distance-based damage, position saturation, inventory enforcement, and error flags. Write a minimal testbench to verify all GAME-01 through GAME-08 requirements.

Purpose: Complete the game core so players can actually fight.
Output: Working game_top.v + tb_game_core.v proving all requirements.
</objective>

<execution_context>
@/Users/alireza/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alireza/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-game-core/02-CONTEXT.md
@.planning/phases/02-game-core/02-01-SUMMARY.md
@game_top.v
@shop.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PLAY phase action logic in game_top.v</name>
  <files>game_top.v</files>
  <action>
Replace the PLAY phase stub in the sequential block with complete action logic. The structure inside `if (phase == PHASE_PLAY)` should be:

```
// Default: clear errors
err_no_inventory <= 1'b0;
err_wrong_distance <= 1'b0;

if (play_valid) begin
    // Determine active player's move counter for the requested action
    // Use a case on play_action to select the counter value

    // INVENTORY CHECK FIRST:
    // If active player's move counter for play_action == 0:
    //   err_no_inventory <= 1'b1;
    //   (no state change, no decrement — skip everything else)
    // Else (counter > 0):
    //   Decrement that move counter by 1
    //   Then execute the action effect
end
```

**Inventory check implementation:** Use `turn` to select P1 or P2 counters. Use a case on `play_action` to read the right counter. Structure as:

```verilog
if (turn == 1'b0) begin // P1 active
    case (play_action)
        ACT_KICK:  if (p1_moves[0] == 4'd0) err_no_inventory <= 1'b1;
                   else begin p1_moves[0] <= p1_moves[0] - 4'd1; /* action effect */ end
        ACT_PUNCH: if (p1_moves[1] == 4'd0) err_no_inventory <= 1'b1;
                   else begin p1_moves[1] <= p1_moves[1] - 4'd1; /* action effect */ end
        ACT_LEFT:  if (p1_moves[2] == 4'd0) err_no_inventory <= 1'b1;
                   else begin p1_moves[2] <= p1_moves[2] - 4'd1; /* action effect */ end
        ACT_RIGHT: if (p1_moves[3] == 4'd0) err_no_inventory <= 1'b1;
                   else begin p1_moves[3] <= p1_moves[3] - 4'd1; /* action effect */ end
        ACT_WAIT:  if (p1_moves[4] == 4'd0) err_no_inventory <= 1'b1;
                   else begin p1_moves[4] <= p1_moves[4] - 4'd1; end // Wait: no effect
        default: ; // invalid action, do nothing
    endcase
end else begin // P2 active — mirror structure
    // Same pattern with p2_moves, p2_pos, p1_health (opponent)
end
```

**Action effects (inside the `else` of each inventory check):**

Kick (ACT_KICK):
- Check `distance == 3'd1`. If yes: decrement OPPONENT health by 1 (e.g., P1 active -> `p2_health <= p2_health - 2'd1`). If no: `err_wrong_distance <= 1'b1;` (no damage, but inventory already decremented).

Punch (ACT_PUNCH):
- Check `distance == 3'd0`. If yes: decrement OPPONENT health by 2 (`p2_health <= p2_health - 2'd2`). If no: `err_wrong_distance <= 1'b1;`.

MoveLeft (ACT_LEFT) — screen-absolute per CONTEXT.md:
- P1 (left side): MoveLeft means pos++ (away from center). `if (p1_pos < 2'd2) p1_pos <= p1_pos + 2'd1;` (saturate at 2).
- P2 (right side): MoveLeft means pos-- (toward center). `if (p2_pos > 2'd0) p2_pos <= p2_pos - 2'd1;` (saturate at 0).

MoveRight (ACT_RIGHT) — screen-absolute:
- P1: MoveRight means pos-- (toward center). `if (p1_pos > 2'd0) p1_pos <= p1_pos - 2'd1;`
- P2: MoveRight means pos++ (away from center). `if (p2_pos < 2'd2) p2_pos <= p2_pos + 2'd1;`

Wait (ACT_WAIT):
- No position or health change. Inventory already decremented above.

**Critical details:**
- `distance` wire is `[2:0]` (3-bit) since max is 4. Comparisons must use 3-bit literals: `3'd0`, `3'd1`.
- Health underflow: do NOT guard against it here (Phase 3 handles win detection before health goes below 0 in normal play). The 2-bit register will naturally wrap, but with health starting at 3 and Punch dealing 2, the min before Phase 3 intervenes is fine.
- Inactive player: the outer `if (turn == 1'b0) / else` ensures only active player's registers are touched. No explicit guard needed beyond this structure.
- No `$display` statements.
- Plain Verilog only.
  </action>
  <verify>Run `iverilog -o /dev/null shop.v game_top.v` — must compile cleanly.</verify>
  <done>PLAY phase processes all 5 action types with correct inventory enforcement, distance-based damage, position saturation, and error flags.</done>
</task>

<task type="auto">
  <name>Task 2: Write tb_game_core.v to verify GAME-01 through GAME-08</name>
  <files>tb_game_core.v</files>
  <action>
Create `tb_game_core.v` in project root. This is a temporary Phase 2 verification TB (Phase 4 writes the final tb_game.v).

**Setup:**
- `timescale 1ns/1ps`, clock with 10ns period
- Instantiate `game_top` with all ports
- Set prices to simple values: Price0=10'd100, Price1=10'd100, Price2=10'd50, Price3=10'd50, Price4=10'd20
- Apply `rst` for 2 cycles, deassert

**Test sequence** (use tasks for readability):

Task `buy_move(input turn_val, input [2:0] action, ...)`:
- Set `buy_valid_p1` or `buy_valid_p2` based on turn_val, set `buy_code_p1/p2` to action, wait 1 cycle, deassert.

Task `play_move(input turn_val, input [2:0] action)`:
- Set `turn`, `play_action`, `play_valid=1`, wait 1 posedge, deassert `play_valid`.

**Test cases (each with $display showing expected vs actual):**

1. **GAME-07: No inventory error** — After reset+start_round, P1 tries Kick with 0 inventory. Expect `err_no_inventory=1`, P1 health/pos unchanged, P2 health/pos unchanged.

2. **Buy moves for testing** — Buy P1: 2x Kick, 1x Punch, 2x MoveRight, 1x MoveLeft, 1x Wait. Buy P2: 2x Kick, 1x MoveLeft, 1x Wait. Then assert `start_round` for 1 cycle to enter PLAY.

3. **GAME-05: Movement with saturation** — P1 starts at pos=2. P1 MoveRight (toward center): pos should become 1. P1 MoveRight again: pos should become 0. Verify P2 unchanged (GAME-01).

4. **GAME-03: Kick at distance=1** — With P1 at pos=0, P2 at pos=2, distance=2. This is wrong distance. P1 Kick -> `err_wrong_distance=1`, P2 health still 3. Then move P2 left (toward center, pos 2->1), distance becomes 0+1=1. P1 Kick -> P2 health should be 2. No err_wrong_distance.

5. **GAME-04: Punch at distance=0** — Move P1 right? No, P1 is at 0. We need distance=0, meaning p1_pos+p2_pos=0, so both at 0. Move P2 left again (pos 1->0). Distance=0. Buy P1 a Punch in shop (need to go back to shop — actually, we already bought 1 Punch for P1 above). Use P1 Punch. P2 health should drop by 2 (from 2 to 0).

6. **GAME-06: Wait** — P2's turn. P2 Wait. Health/pos unchanged. Wait counter decremented.

7. **GAME-08: Inventory decrement** — Verify a move counter went from initial to expected value via observing err_no_inventory when counter should be 0.

Use `$display` for each test showing test name, expected, actual values. End with `$display("--- tb_game_core complete ---");` and `$finish`.

**Important:** The TB must handle the SHOP->PLAY transition. After buying moves, pulse `start_round` high for 1 cycle to enter PLAY phase. After any test that needs more moves, you'd need to go back to SHOP — but for simplicity, buy all needed moves upfront before entering PLAY.

**Movement direction reminder for TB:**
- P1 MoveRight (action 3): P1 pos decreases (toward center)
- P1 MoveLeft (action 2): P1 pos increases (away from center)
- P2 MoveLeft (action 2): P2 pos decreases (toward center)
- P2 MoveRight (action 3): P2 pos increases (away from center)
  </action>
  <verify>Run `iverilog -o tb_game_core shop.v game_top.v tb_game_core.v && vvp tb_game_core` — all tests should show matching expected/actual values and end with `--- tb_game_core complete ---`.</verify>
  <done>All GAME-01 through GAME-08 requirements demonstrated: turn isolation, kick damage at d=1, punch damage at d=0, wrong-distance error, movement saturation, inventory enforcement (err_no_inventory), inventory decrement, and wait no-op.</done>
</task>

</tasks>

<verification>
- `iverilog -o tb_game_core shop.v game_top.v tb_game_core.v && vvp tb_game_core` runs clean
- No SystemVerilog in game_top.v
- No `$display` in game_top.v (only in tb_game_core.v)
- GAME-01: Only active player state changes per turn
- GAME-02: Position stored in 2-bit registers
- GAME-03: Kick at distance=1 deals 1 damage
- GAME-04: Punch at distance=0 deals 2 damage
- GAME-05: Position saturates at 0 and 2
- GAME-06: Wait consumes counter, no other change
- GAME-07: Counter=0 triggers err_no_inventory, no state change
- GAME-08: Valid action decrements counter
</verification>

<success_criteria>
tb_game_core.v passes all tests demonstrating every GAME requirement. game_top.v PLAY logic is complete and correct.
</success_criteria>

<output>
After completion, create `.planning/phases/02-game-core/02-02-SUMMARY.md`
</output>
