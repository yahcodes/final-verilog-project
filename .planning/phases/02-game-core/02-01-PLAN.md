---
phase: 02-game-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [game_top.v]
autonomous: true

must_haves:
  truths:
    - "game_top.v compiles with iverilog alongside shop.v"
    - "Two shop instances are wired with correct ports"
    - "Phase register exists (SHOP=1, PLAY=0) and resets to SHOP"
    - "Health, position, credit, and move counter registers exist for both players"
    - "Turn input selects which player's action is processed"
  artifacts:
    - path: "game_top.v"
      provides: "FSM skeleton with registers, shop instantiation, port interface"
      contains: "module game_top"
  key_links:
    - from: "game_top.v"
      to: "shop.v"
      via: "shop_p1 and shop_p2 instantiation"
      pattern: "shop shop_p[12]"
---

<objective>
Create game_top.v with the full port interface, all game registers, two shop instantiations, and the PLAY/SHOP phase FSM skeleton. PLAY action logic will be stubbed (no-op) -- Plan 02 fills it in.

Purpose: Establish the module structure so Plan 02 can focus purely on game logic.
Output: game_top.v that compiles cleanly with shop.v.
</objective>

<execution_context>
@/Users/alireza/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alireza/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-game-core/02-CONTEXT.md
@.planning/phases/01-shop-module/01-01-SUMMARY.md
@shop.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game_top.v module skeleton with registers and shop wiring</name>
  <files>game_top.v</files>
  <action>
Create `game_top.v` in project root with the following structure:

**Module declaration** — exact port list from CONTEXT.md:
- Inputs: `clk`, `rst`, `turn`, `play_valid`, `play_action[2:0]`, `buy_valid_p1`, `buy_code_p1[2:0]`, `buy_valid_p2`, `buy_code_p2[2:0]`, `start_round`, `Price0`-`Price4` (all `[9:0]`)
- Outputs: `phase`, `p1_health[1:0]`, `p2_health[1:0]`, `p1_credit[9:0]`, `p2_credit[9:0]`, `p1_pos[1:0]`, `p2_pos[1:0]`, `winner[1:0]`, `err_invalid_action_p1`, `err_credit_p1`, `err_out_of_stock_p1`, `purchase_success_p1`, `err_invalid_action_p2`, `err_credit_p2`, `err_out_of_stock_p2`, `purchase_success_p2`, `err_no_inventory`, `err_wrong_distance`

**Localparams:**
- `PHASE_PLAY = 1'b0`, `PHASE_SHOP = 1'b1`
- `ACT_KICK = 3'd0`, `ACT_PUNCH = 3'd1`, `ACT_LEFT = 3'd2`, `ACT_RIGHT = 3'd3`, `ACT_WAIT = 3'd4`

**Registers (all `reg`):**
- `phase` (1-bit)
- `p1_health[1:0]`, `p2_health[1:0]` — reset to 2'd3
- `p1_credit[9:0]`, `p2_credit[9:0]` — reset to 10'd500
- `p1_pos[1:0]`, `p2_pos[1:0]` — reset to 2'd2
- `p1_moves[0:4]` and `p2_moves[0:4]` — each `[3:0]`, unpacked array of 5 entries, reset to 0
- `winner[1:0]` — reset to 2'b00
- `err_no_inventory` (reg), `err_wrong_distance` (reg) — reset to 0

**Combinational wires:**
- `wire [1:0] distance = p1_pos + p2_pos;` (2-bit sum, max 4 fits in 3 bits but use `[2:0]` to be safe — actually use `wire [2:0] distance` since 2+2=4 needs 3 bits)

**Shop instance wiring:**
- Internal wires: `p1_credit_next[9:0]`, `p2_credit_next[9:0]`, `p1_grant_onehot[4:0]`, `p2_grant_onehot[4:0]`
- `discount_mult` hardcoded to `7'd100` (no discount in Phase 2)
- Instantiate `shop shop_p1(...)` and `shop shop_p2(...)` per the pattern in 01-01-SUMMARY.md
  - shop_p1: `.buy_valid(buy_valid_p1)`, `.action_number(buy_code_p1)`, `.credit_in(p1_credit)`, `.discount_mult(7'd100)`, prices wired through, outputs to `purchase_success_p1`, `err_invalid_action_p1`, `err_credit_p1`, `err_out_of_stock_p1`, `p1_credit_next`, `p1_grant_onehot`
  - shop_p2: same pattern for P2

**Sequential block** `always @(posedge clk or posedge rst)`:

Reset block:
- `phase <= PHASE_SHOP`
- health to 3, credit to 500, pos to 2, all moves to 0, winner to 0, errors to 0

Non-reset block (skeleton):
- **SHOP phase**: On each cycle, latch `p1_credit <= p1_credit_next` and `p2_credit <= p2_credit_next`. For each bit in `p1_grant_onehot`, increment the corresponding `p1_moves[i]` (use 5 individual if-statements: `if (p1_grant_onehot[0]) p1_moves[0] <= p1_moves[0] + 4'd1;` etc). Same for P2. Handle `start_round` input: `if (start_round) phase <= PHASE_PLAY;` (just the phase flip for now).
- **PLAY phase**: Clear `err_no_inventory` and `err_wrong_distance` to 0 at start of PLAY block. Then: `if (play_valid) begin /* STUB: Plan 02 fills in action logic */ end`. For now the stub should just set both errors to 0 and do nothing else.
- Default: `err_no_inventory <= 0; err_wrong_distance <= 0;`

**Important details:**
- All outputs that come from shop instances are `wire` (directly connected), not `reg`
- `err_no_inventory` and `err_wrong_distance` are `output reg` since they are set in the sequential block
- Use plain Verilog only. No `logic`, no `always_comb`, no `always_ff`.
- No `$display` statements.
  </action>
  <verify>Run `iverilog -o /dev/null shop.v game_top.v` — must exit 0 with no errors. Warnings about unused `start_round` stub logic are acceptable.</verify>
  <done>game_top.v exists, compiles cleanly with shop.v, has all ports from CONTEXT.md, two shop instances wired, all registers with correct reset values, SHOP phase latches credit and increments move counters from grant_onehot, PLAY phase has a stub ready for Plan 02.</done>
</task>

</tasks>

<verification>
- `iverilog -o /dev/null shop.v game_top.v` exits 0
- game_top.v contains no SystemVerilog keywords
- game_top.v contains no `$display`
- All ports from CONTEXT.md present in module declaration
- Both shop instances present
</verification>

<success_criteria>
game_top.v compiles with shop.v. All registers, ports, shop wiring, and SHOP-phase credit/inventory logic are in place. PLAY stub is ready for Plan 02 to fill in.
</success_criteria>

<output>
After completion, create `.planning/phases/02-game-core/02-01-SUMMARY.md`
</output>
