---
phase: 04-display-and-testbench
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - tb_game.v
autonomous: true

must_haves:
  truths:
    - "Simulation output shows an invalid action error (buy_code >= 5)"
    - "Simulation output shows an insufficient credit error"
    - "Simulation output shows an out-of-stock error"
    - "Simulation output shows movement saturation at left boundary (p1_pos stays at 2)"
    - "Simulation output shows movement saturation at right boundary (p1_pos stays at 0)"
    - "Simulation output shows punch at distance 0 dealing 2 damage"
    - "Simulation output shows kick at distance 1 dealing 1 damage"
    - "Simulation output shows a full win path with correct winner output"
    - "Simulation output shows all three discount bands (80, 90, 95)"
  artifacts:
    - path: "tb_game.v"
      provides: "Comprehensive testbench exercising all TB-01 scenarios"
      min_lines: 200
  key_links:
    - from: "tb_game.v"
      to: "game_top.v"
      via: "module instantiation"
      pattern: "game_top\\s+uut"
---

<objective>
Write tb_game.v that exercises all 8 TB-01 scenarios and produces visible pass/fail output via $display. Run the simulation to confirm all scenarios produce expected output.

Purpose: TB-01 requires a comprehensive testbench proving all game mechanics work end-to-end.
Output: tb_game.v file, successful simulation run.
</objective>

<execution_context>
@/Users/alireza/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alireza/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@shop.v
@game_top.v
@.planning/phases/04-display-and-testbench/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tb_game.v with all required scenarios</name>
  <files>tb_game.v</files>
  <action>
Create tb_game.v with:

**Clock and reset:**
- `reg clk = 0; always #5 clk = ~clk;` (10ns period)

**DUT instantiation:**
- Instantiate `game_top uut(...)` with all ports wired to regs/wires
- Set prices: Price0=100, Price1=120, Price2=50, Price3=50, Price4=30

**Helper tasks:**

```verilog
task buy_p1(input [2:0] code);
begin
    buy_valid_p1 = 1; buy_code_p1 = code;
    @(posedge clk); // shop latches grant
    @(posedge clk); // game_top reads grant, updates inventory
    buy_valid_p1 = 0;
end
endtask

task buy_p2(input [2:0] code);
begin
    buy_valid_p2 = 1; buy_code_p2 = code;
    @(posedge clk);
    @(posedge clk);
    buy_valid_p2 = 0;
end
endtask

task do_play(input t, input [2:0] act);
begin
    turn = t; play_action = act; play_valid = 1;
    @(posedge clk);
    play_valid = 0;
    @(posedge clk); // settle
end
endtask

task do_reset;
begin
    rst = 1; @(posedge clk); @(posedge clk); rst = 0; @(posedge clk);
end
endtask

task do_start_round;
begin
    start_round = 1; @(posedge clk); start_round = 0; @(posedge clk);
end
endtask
```

**Test sequence (all in initial block):**

IMPLEMENT EXACTLY THIS SEQUENCE. Each numbered step is one task call or check. No deviations.

```
$display("=== TB_GAME START ===");

=== GROUP A: Error tests + combat tests ===
1. do_reset
2. buy_p1(5) — invalid action [TEST 1: err_invalid_action]
3. buy_p1(4) x5 — 5x Wait at 30 each = 150 total. P1 credit: 500->350. Wait stock: 5->0.
4. buy_p1(4) — 6th Wait attempt -> ERR_OUT_OF_STOCK [TEST 2: err_out_of_stock]
5. buy_p1(2) x1 — 1x Left(2) at 50. P1 credit: 350->300.
6. buy_p1(3) x3 — 3x Right(3) at 50 each = 150. P1 credit: 300->150.
7. buy_p1(0) x1 — 1x Kick(0) at 100. P1 credit: 150->50.
8. buy_p1(1) — Punch(1) at 120, P1 credit=50 < 120 -> ERR_CREDIT [TEST 3: err_credit]
9. buy_p2(0) x2 — 2x Kick(0) at 100 each = 200. P2 credit: 500->300.
10. buy_p2(1) x1 — 1x Punch(1) at 120. P2 credit: 300->180.
11. buy_p2(2) x2 — 2x Left(2) at 50 each = 100. P2 credit: 180->80.
12. do_start_round — phase -> PLAY

=== PLAY TESTS ===
13. do_play(0, 2) — P1 MoveLeft. p1_pos=2, already max, stays 2. [TEST 4: left saturation]
    Check: p1_pos == 2
14. do_play(0, 3) — P1 MoveRight: p1_pos 2->1.
15. do_play(0, 3) — P1 MoveRight: p1_pos 1->0.
16. do_play(0, 3) — P1 MoveRight at pos=0, stays 0. [TEST 5: right saturation]
    Check: p1_pos == 0
    Now: P1 pos=0, P2 pos=2. dist=2.
17. do_play(1, 2) — P2 MoveLeft: p2_pos 2->1. dist = 0+1 = 1.
18. do_play(1, 0) — P2 Kick at dist=1: P1 health 3->2. [TEST 7: kick at dist=1, 1 damage]
    Check: p1_health == 2
19. do_play(1, 2) — P2 MoveLeft: p2_pos 1->0. dist = 0+0 = 0.
20. do_play(1, 1) — P2 Punch at dist=0: P1 health 2->0 (2<=2 -> WIN). [TEST 6: punch dist=0, TEST 8: win]
    P2 wins: winner=2'b10. mtw=8 (P1: Left,Right,Right,Right=4; P2: Left,Kick,Left,Punch=4).
    Band 2 (7-9), mult=90.
    Check: winner==2'b10, phase==PHASE_SHOP

=== GROUP B: Verify band 2 discount (10% off, mult=90) ===
21. buy_p2(0) — P2 buys Kick(0): price=100, discounted=90. [TEST 9a: band 2]
    Check: Discounted price = 90 in [SHOP] output

=== GROUP C: Band 1 discount (20% off, mult=80, <=6 moves) ===
22. do_reset
23. buy_p1(1) x2 — 2x Punch(1) at 120 each = 240. P1 credit: 500->260.
24. buy_p1(3) x2 — 2x Right(3) at 50 each = 100. P1 credit: 260->160.
25. buy_p2(2) x2 — 2x Left(2) at 50 each = 100. P2 credit: 500->400.
26. do_start_round — phase -> PLAY
27. do_play(0, 3) — P1 MoveRight: p1_pos 2->1. (mtw=1)
28. do_play(0, 3) — P1 MoveRight: p1_pos 1->0. (mtw=2)
29. do_play(1, 2) — P2 MoveLeft: p2_pos 2->1. (mtw=3)
30. do_play(1, 2) — P2 MoveLeft: p2_pos 1->0. dist=0. (mtw=4)
31. do_play(0, 1) — P1 Punch at dist=0: P2 health 3->1. (mtw=5)
32. do_play(0, 1) — P1 Punch at dist=0: P2 health 1<=2 -> WIN. (mtw=6). Winner=P1(01). Band 1.
    Check: winner==2'b01, phase==PHASE_SHOP
33. buy_p1(0) — P1 buys Kick(0): price=100, discounted=80. [TEST 9b: band 1]
    Check: Discounted = 80

=== GROUP D: Band 3 discount (5% off, mult=95, >=10 moves) ===
34. do_reset
35. buy_p1(1) x2 — 2x Punch(1) at 120 each = 240. P1 credit: 500->260.
36. buy_p1(3) x2 — 2x Right(3) at 50 each = 100. P1 credit: 260->160.
37. buy_p1(4) x5 — 5x Wait(4) at 30 each = 150. P1 credit: 160->10.
38. buy_p2(2) x2 — 2x Left(2) at 50 each = 100. P2 credit: 500->400.
39. buy_p2(4) x5 — 5x Wait(4) at 30 each = 150. P2 credit: 400->250.
40. do_start_round — phase -> PLAY
41. do_play(0, 3) — P1 MoveRight: p1_pos 2->1. (mtw=1)
42. do_play(0, 3) — P1 MoveRight: p1_pos 1->0. (mtw=2)
43. do_play(1, 2) — P2 MoveLeft: p2_pos 2->1. (mtw=3)
44. do_play(1, 2) — P2 MoveLeft: p2_pos 1->0. dist=0. (mtw=4)
45. do_play(0, 4) x5 — P1 Wait x5: mtw=5,6,7,8,9.
46. do_play(1, 4) x1 — P2 Wait x1: mtw=10.
47. do_play(0, 1) — P1 Punch: P2 health 3->1. (mtw=11)
48. do_play(0, 1) — P1 Punch: P2 health 1<=2 -> WIN. (mtw=12). Winner=P1. Band 3.
    Check: winner==2'b01, phase==PHASE_SHOP
49. buy_p1(0) — P1 buys Kick(0): price=100, discounted=95. [TEST 9c: band 3]
    Check: Discounted = 95

50. $display("=== TB_GAME COMPLETE ==="); $finish;
```

IMPORTANT: P2 uses MoveLeft (action code 2) to move toward center. P2 starts at pos=2, MoveLeft decreases pos: 2->1->0. Do NOT use MoveRight (code 3) for P2 — that would increase pos and saturate at 2.

IMPORTANT implementation details:
- After key play actions, check outputs with if/else and $display PASS/FAIL:
  ```verilog
  if (uut.p1_health == 2'd2) $display("PASS: P1 health reduced to 2");
  else $display("FAIL: expected P1 health=2, got %0d", uut.p1_health);
  ```
- Use `@(posedge clk);` for timing.
- Deassert all buy_valid and play_valid signals between operations.
- For repetitive buys (e.g., "buy_p1(4) x5"), use a for loop or 5 sequential calls.
  </action>
  <verify>
Run:
```
cd /Users/alireza/Documents/Claude/Yahya && iverilog -o tb_game.vvp shop.v game_top.v tb_game.v && vvp tb_game.vvp
```
Confirm:
1. Output contains "ERR_INVALID_ACTION" (test 1)
2. Output contains "ERR_OUT_OF_STOCK" (test 2)
3. Output contains "ERR_CREDIT" (test 3)
4. Output shows p1_pos=2 after MoveLeft at pos=2 (test 4)
5. Output shows p1_pos=0 after MoveRight at pos=0 (test 5)
6. Output shows punch dealing 2 damage at dist=0 (test 6)
7. Output shows kick dealing 1 damage at dist=1 (test 7)
8. Output shows winner=1 or winner=2 after health reaches 0 (test 8)
9. Output shows Discounted=90 (band 2), Discounted=80 (band 1), Discounted=95 (band 3) (test 9)
10. Output ends with "TB_GAME COMPLETE"
  </verify>
  <done>tb_game.v compiles and simulates successfully. Simulation output covers all 8 TB-01 requirements: invalid action error, insufficient credit error, out-of-stock error, both-edge movement saturation, punch at dist 0 (2 damage), kick at dist 1 (1 damage), full win path with correct winner, and all three discount bands (80, 90, 95).</done>
</task>

</tasks>

<verification>
1. `iverilog -o tb_game.vvp shop.v game_top.v tb_game.v` compiles cleanly
2. `vvp tb_game.vvp` produces output covering all 8 TB-01 scenarios
3. No FAIL messages in output (all PASS checks succeed)
4. Output contains "TB_GAME COMPLETE" (simulation ran to completion)
</verification>

<success_criteria>
- tb_game.v exists and compiles with iverilog
- Simulation produces visible output for all 8 required scenarios
- All PASS/FAIL checks show PASS
- All three discount bands verified (80, 90, 95)
- Simulation completes without hanging
</success_criteria>

<output>
After completion, create `.planning/phases/04-display-and-testbench/04-02-SUMMARY.md`
</output>
